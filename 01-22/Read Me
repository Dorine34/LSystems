Hello camarade !

Fichier cpp est remastorisé et terminé, de façon à rendre interactif.

Je n'ai pas fait la 2D, mais j'y ai quand meme reflechi. Je te laisse, comme convenu, t'en charger.
Tu trouveras, ci-apres quelques codes et pistes de reflexions qui peuvent peut etre aider 
(j'avoue le probleme n'est pas facile).
De même, si samedi soir, tu n'as pas avancé. Previens moi (telephone), et je le realiserai dimanche (en semaine, je risque d'avoir beaucoup moins le temps), pour le passer lundi à Clement.
Inutile de te dire que je préfèrerai un code pas terrible (même si ça ne me paraît peu probable venant de toi) made in Nicolas qu'un code magnifique venant de Kailas.

En tout cas merci bien pour ton conseil le "fprints" a enormement simplifié le code.

N'oublie pas, si tu arrives à faire la 2D avant samedi soir de passer le code à Clément et à moi (ça m'interesse, car actuellement, je suis bloquée).

Annexes: avec "#define PI 3.14159265"

int calculInclinaison(int a){//permet d'avoir l'inclinaison d'une branche
  if (a>=360){return (a-360);}
  if (a<0){return (360+a);}
} 


double CalculDegreAbs(double base, int inclinaison){//permet d'avoir l'abscisse selon l'inclinaison
  double g= PI * inclinaison / 180;//calcul en radian
  return base+10*cos(g); 
}

double CalculDegreOrd(double base, int inclinaison){//permet d'avoir l'ordonnee selon l'inclinaison
  double g= PI * inclinaison / 180;//calcul en radian
  return base+10*sin(g); 
}

struct Element
{
    int rang;//etage sur lequel est la feuille
    char nom;//'a' ou 'b'
    int abscisse;
    int ordonnee;
    double inclinaison;//inclinaison de sa branche
    struct Element *enfantA;//son enfant de type 'a' ==NULL si absent
    struct Element *enfantB;//son enfant de type 'b'
};

void ajoutFeuille( char k, Element *parent)//pour ajouter une feuille
{
    Element *elem = (Element*)malloc(sizeof(Element));
    elem->nom = k;
    elem->enfantA = NULL;
    elem->enfantB = NULL;
    elem->rang= parent->rang+1;

    //completement arbitraire :'(
    if (k=='a'){
      parent->enfantA= elem;
      elem->inclinaison = calculInclinaison(parent->inclinaison+15);
    }
    else{
      parent->enfantB=elem;
      elem->inclinaison =calculInclinaison(parent->inclinaison-15);
    } 
    elem->abscisse=CalculDegreAbs( parent->abscisse,elem->inclinaison);
    elem->ordonnee=CalculDegreAbs( parent->ordonnee,elem->inclinaison);
}

//la fonction d'affichage ->copie/colle de kruskal
void AffichageGraphique2(int n, int point[][2], int arbre[][2])       // Cree le fichier Exemple.ps qui affiche
                                                                     // les points et l'arbre de Kruskal.
{ofstream output;                           
 output.open("arbre.ps",ios::out);
 output << "%!PS-Adobe-3.0" << endl;
 output << "%%BoundingBox: 0 0 612 792" << endl;
 output << endl;  
 for(int i=0;i<n;i++)
   {output << point[i][0] << " " << point[i][1] << " 3 0 360 arc" <<endl;
   output << "0 setgray" <<endl;
   output << "fill" <<endl;
   output << "stroke"<<endl;
   output << endl;
   }
 output << endl;
 for(int i=0;i<n-1;i++)
   {output << point[arbre[i][0]][0] << " " << point[arbre[i][0]][1] 
     << " moveto" << endl;
   output << point[arbre[i][1]][0] << " " << point[arbre[i][1]][1] 
    << " lineto" << endl;
   output << "stroke" << endl;
   output << endl;
   }
 output << "showpage";
 output << endl;
}


Courage ! Une fois cette partie finie, tu pourras t'amuser avec des logiciels type blender !
J'ai quelques idees pour ma part bien sympa que j'aimerai mettre en pratique^^ Mais pour cela, faut que la partie chiante soit finie.

Bon week end,
Ta dévouée,
Dorine